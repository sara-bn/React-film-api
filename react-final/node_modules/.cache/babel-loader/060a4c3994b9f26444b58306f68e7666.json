{"ast":null,"code":"/**\r\n * @copyright 2015, Andrey Popp <8mayday@gmail.com>\r\n *\r\n * The decorator may be used on classes or methods\r\n * ```\r\n * @autobind\r\n * class FullBound {}\r\n *\r\n * class PartBound {\r\n *   @autobind\r\n *   method () {}\r\n * }\r\n * ```\r\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = autobind;\n\nfunction autobind() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 1) {\n    return boundClass.apply(undefined, args);\n  } else {\n    return boundMethod.apply(undefined, args);\n  }\n}\n/**\r\n * Use boundMethod to bind all methods on the target.prototype\r\n */\n\n\nfunction boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys = undefined; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\n/**\r\n * Return a descriptor removing the value and returning a getter\r\n * The getter will return a .bind version of the function\r\n * and memoize the result against a symbol on the instance\r\n */\n\n\nfunction boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        value: boundFn,\n        configurable: true,\n        writable: true\n      });\n      definingProperty = false;\n      return boundFn;\n    }\n  };\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["C:/Users/reyar/Desktop/SSD Projects/React-film-api/react-final/node_modules/autobind-decorator/lib/index.js"],"names":["Object","defineProperty","exports","value","autobind","_len","arguments","length","args","Array","_key","boundClass","apply","undefined","boundMethod","target","keys","Reflect","ownKeys","prototype","getOwnPropertyNames","getOwnPropertySymbols","concat","forEach","key","descriptor","getOwnPropertyDescriptor","fn","Error","definingProperty","configurable","get","hasOwnProperty","boundFn","bind","writable","module"],"mappings":"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","sourcesContent":["/**\r\n * @copyright 2015, Andrey Popp <8mayday@gmail.com>\r\n *\r\n * The decorator may be used on classes or methods\r\n * ```\r\n * @autobind\r\n * class FullBound {}\r\n *\r\n * class PartBound {\r\n *   @autobind\r\n *   method () {}\r\n * }\r\n * ```\r\n */\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', {\r\n  value: true\r\n});\r\nexports['default'] = autobind;\r\n\r\nfunction autobind() {\r\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\r\n    args[_key] = arguments[_key];\r\n  }\r\n\r\n  if (args.length === 1) {\r\n    return boundClass.apply(undefined, args);\r\n  } else {\r\n    return boundMethod.apply(undefined, args);\r\n  }\r\n}\r\n\r\n/**\r\n * Use boundMethod to bind all methods on the target.prototype\r\n */\r\nfunction boundClass(target) {\r\n  // (Using reflect to get all keys including symbols)\r\n  var keys = undefined;\r\n  // Use Reflect if exists\r\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\r\n    keys = Reflect.ownKeys(target.prototype);\r\n  } else {\r\n    keys = Object.getOwnPropertyNames(target.prototype);\r\n    // use symbols if support is provided\r\n    if (typeof Object.getOwnPropertySymbols === 'function') {\r\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\r\n    }\r\n  }\r\n\r\n  keys.forEach(function (key) {\r\n    // Ignore special case target method\r\n    if (key === 'constructor') {\r\n      return;\r\n    }\r\n\r\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);\r\n\r\n    // Only methods need binding\r\n    if (typeof descriptor.value === 'function') {\r\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\r\n    }\r\n  });\r\n  return target;\r\n}\r\n\r\n/**\r\n * Return a descriptor removing the value and returning a getter\r\n * The getter will return a .bind version of the function\r\n * and memoize the result against a symbol on the instance\r\n */\r\nfunction boundMethod(target, key, descriptor) {\r\n  var fn = descriptor.value;\r\n\r\n  if (typeof fn !== 'function') {\r\n    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);\r\n  }\r\n\r\n  // In IE11 calling Object.defineProperty has a side-effect of evaluating the\r\n  // getter for the property which is being replaced. This causes infinite\r\n  // recursion and an \"Out of stack space\" error.\r\n  var definingProperty = false;\r\n\r\n  return {\r\n    configurable: true,\r\n    get: function get() {\r\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {\r\n        return fn;\r\n      }\r\n\r\n      var boundFn = fn.bind(this);\r\n      definingProperty = true;\r\n      Object.defineProperty(this, key, {\r\n        value: boundFn,\r\n        configurable: true,\r\n        writable: true\r\n      });\r\n      definingProperty = false;\r\n      return boundFn;\r\n    }\r\n  };\r\n}\r\nmodule.exports = exports['default'];\r\n"]},"metadata":{},"sourceType":"script"}